import request from '../utils/request.js'
import {
	AllowedMentions,
	Application,
	Attachment,
	Channel,
	ChannelMention,
	Component,
	Embed,
	Message,
	MessageActivity,
	MessageInteraction,
	MessageReference,
	Reaction,
	RoleSubscriptionData,
	Snowflake,
	Sticker,
	StickerItem,
	User
} from '../types'
import toCamelCase from '../utils/toCamelCase.js'

class FollowupMessage {
	/** id of the message */
	id!: Snowflake
	/** id of the channel the message was sent in */
	channelId!: Snowflake
	/** the author of this message (not guaranteed to be a valid user) */
	author!: User
	/** contents of the message */
	content!: string
	/** when this message was sent */
	timestamp!: string
	/** when this message was edited (or null if never) */
	editedTimestamp!: string | null
	/** whether this was a TTS message */
	tts!: boolean
	/** whether this message mentions everyone */
	mentionEveryone!: boolean
	/** users specifically mentioned in the message */
	mentions!: User[]
	/** roles specifically mentioned in this message */
	mentionRoles!: string[]
	/** channels specifically mentioned in this message */
	mentionChannels?: ChannelMention[]
	/** any attached files */
	attachments!: Attachment[]
	/** any embedded content */
	embeds!: Embed[]
	/** reactions to the message */
	reactions!: Reaction[]
	/** used for validating a message was sent */
	nonce?: number | string
	/** whether this message is pinned */
	pinned!: boolean
	/** if the message is generated by a webhook, this is the webhook's id */
	webhookId?: Snowflake
	/** type of message */
	type!: number
	/** sent with Rich Presence-related chat embeds */
	activity?: MessageActivity
	/** sent with Rich Presence-related chat embeds */
	application?: Partial<Application>
	/** if the message is an Interaction or application-owned webhook, this is the id of the application */
	applicationId?: Snowflake
	/** data showing the source of a crosspost, channel follow add, pin, or reply message */
	messageReference?: MessageReference
	/** message flags combined as a bitfield */
	flags?: number
	/** the message associated with the messageReference */
	referencedMessage?: Message | null
	/** sent if the message is a response to an Interaction */
	interaction?: MessageInteraction
	/** the thread that was started from this message, includes thread member object */
	thread?: Channel
	/** sent if the message contains components like buttons, action rows, or other interactive components */
	components?: Component[]
	/** sent if the message contains stickers */
	stickerItems?: StickerItem[]
	/** the stickers sent with the message **(deprecated)** */
	stickers?: Sticker[]
	/** A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with totalMessageSent on parent thread */
	position?: number
	/** data of the role subscription purchase or renewal that prompted this ROLE_SUBSCRIPTION_PURCHASE message */
	roleSubscriptionData?: RoleSubscriptionData
	token: string

	/** Gets this followup message
	 *
	 * Also updates this class instance
	 */
	async get() {
		const result = await get(this.token, this.id)
		Object.assign(this, result)
		return result
	}
	/** Edits this followup message
	 *
	 * Also updates this class instance
	 */
	async edit(newMessage: EditParams) {
		const result = await edit(this.token, this.id, newMessage)
		Object.assign(this, result)
		return result
	}
	/** Deletes this followup message
	 *
	 * Also updates this class instance
	 */
	async delete() {
		return await _delete(this.token, this.id)
	}
	constructor(data: Message, token: string) {
		Object.assign(this, toCamelCase(data))

		this.token = token
	}
}
/** Creates a followup message */
async function create(
	token: string,
	/** The message to send - **One of content, files, or embeds is required** */
	message: {
		/** the message contents (up to 2000 characters) */
		content?: string
		/** true if this is a TTS message */
		tts?: boolean
		/** embedded rich content */
		embeds?: Embed[]
		/** allowed mentions for the message */
		allowedMentions?: AllowedMentions
		/** the components to include with the message */
		components?: Component[]
		/** the contents of the file being sent */
		files?: string[]
		/** attachment objects with filename and description */
		attachments?: Partial<Attachment>[]
		/** message flags combined as a bitfield (only SUPPRESS_EMBEDS can be set) */
		flags?: number
		/** name of thread to create (requires the webhook channel to be a forum channel) */
		threadName?: string
	} & (
		| { content: string; files?: string[]; embeds?: Embed[] }
		| { content?: string; files: string[]; embeds?: Embed[] }
		| { content?: string; files?: string[]; embeds: Embed[] }
	)
): Promise<FollowupMessage> {
	return new FollowupMessage(
		(await request.post(
			`webhooks/{APP_ID}/${token}`,
			message
		)) as unknown as Message,
		token
	)
}
/** Gets a followup message */
async function get(
	token: string,
	messageId: Snowflake
): Promise<FollowupMessage> {
	return new FollowupMessage(
		(await request.get(
			`webhooks/{APP_ID}/${token}/messages/${messageId}`
		)) as unknown as Message,
		token
	)
}
type EditParams = {
	/** the message contents (up to 2000 characters) */
	content?: string
	/** embedded `rich` content */
	embeds?: Embed[]
	/** allowed mentions for the message */
	allowedMentions?: AllowedMentions
	/** the components to include with the message */
	components?: Component[]
	/** the contents of the file being sent/edited */
	files?: string[]
	/** attached files to keep and possible descriptions for new files */
	attachments?: Partial<Attachment>[]
}
/** Edits a followup message */
async function edit(
	token: string,
	messageId: Snowflake,
	message: EditParams
): Promise<FollowupMessage> {
	return new FollowupMessage(
		(await request.patch(
			`webhooks/{APP_ID}/${token}/messages/${messageId}`,
			message
		)) as unknown as Message,
		token
	)
}
async function _delete(token: string, messageId: Snowflake): Promise<void> {
	return (await request.delete(
		`webhooks/{APP_ID}/${token}/messages/${messageId}`
	)) as unknown as void
}
export default { create, get, edit, delete: _delete }
