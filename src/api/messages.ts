import request from '../utils/request.js'
import toCamelCase from '../utils/toCamelCase.js'

import type { Channel } from './channels'
import type { User } from './users'
import type { Sticker, StickerItem } from './stickers'
import type { Reaction } from './reactions'
import type {
	Snowflake,
	Embed,
	AllowedMentions,
	Component,
	Attachment,
	MessageReference,
	ChannelMention,
	MessageActivity,
	Application,
	RoleSubscriptionData
} from '../types'
import { InteractionType } from 'src/enums.js'
import { GuildMember } from './members.js'

export class BaseMessage {
	/** id of the message */
	id!: Snowflake
	/** id of the channel the message was sent in */
	channelId!: Snowflake
	/** the author of this message (not guaranteed to be a valid user) */
	author!: User
	/** contents of the message */
	content!: string
	/** when this message was sent */
	timestamp!: string
	/** when this message was edited (or null if never) */
	editedTimestamp!: string | null
	/** whether this was a TTS message */
	tts!: boolean
	/** whether this message mentions everyone */
	mentionEveryone!: boolean
	/** users specifically mentioned in the message */
	mentions!: User[]
	/** roles specifically mentioned in this message */
	mentionRoles!: string[]
	/** channels specifically mentioned in this message */
	mentionChannels?: ChannelMention[]
	/** any attached files */
	attachments!: Attachment[]
	/** any embedded content */
	embeds!: Embed[]
	/** reactions to the message */
	reactions!: Reaction[]
	/** used for validating a message was sent */
	nonce?: number | string
	/** whether this message is pinned */
	pinned!: boolean
	/** if the message is generated by a webhook, this is the webhook's id */
	webhookId?: Snowflake
	/** type of message */
	type!: MessageType
	/** sent with Rich Presence-related chat embeds */
	activity?: MessageActivity
	/** sent with Rich Presence-related chat embeds */
	application?: Partial<Application>
	/** if the message is an Interaction or application-owned webhook, this is the id of the application */
	applicationId?: Snowflake
	/** data showing the source of a crosspost, channel follow add, pin, or reply message */
	messageReference?: MessageReference
	/** message flags combined as a bitfield */
	flags?: number
	/** the message associated with the messageReference */
	referencedMessage?: _Message | null
	/** sent if the message is a response to an Interaction */
	interaction?: MessageInteraction
	/** the thread that was started from this message, includes thread member object */
	thread?: Channel
	/** sent if the message contains components like buttons, action rows, or other interactive components */
	components?: Component[]
	/** sent if the message contains stickers */
	stickerItems?: StickerItem[]
	/** the stickers sent with the message **(deprecated)** */
	stickers?: Sticker[]
	/** A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with totalMessageSent on parent thread */
	position?: number
	/** data of the role subscription purchase or renewal that prompted this ROLE_SUBSCRIPTION_PURCHASE message */
	roleSubscriptionData?: RoleSubscriptionData

	constructor(data: unknown) {
		if (data) Object.assign(this, toCamelCase(data))
	}
}
class Message extends BaseMessage {
	/** Gets this message
	 *
	 * Also updates this class instance
	 */
	async get() {
		const result = await get(this.channelId, this.id)
		Object.assign(this, result)
		return result
	}

	/** Edits this message
	 *
	 * Also updates this class instance
	 */
	async edit(newMessage: EditParams) {
		const result = await edit(this.channelId, this.id, newMessage)
		Object.assign(this, result)
		return result
	}

	/** Deletes this message */
	async delete() {
		return await _delete(this.channelId, this.id)
	}

	constructor(data: unknown) {
		super(data)
	}
}
/** Creates a new message */
async function create(
	channelId: Snowflake,
	message: {
		/** Message contents (up to 2000 characters) */
		content?: string
		/** Can be used to verify a message was sent (up to 25 characters). Value will appear in the Message Create event. */
		nonce?: number | string
		/** `true` if this is a TTS message */
		tts?: boolean
		/** Up to 10 `rich` embeds (up to 6000 characters) */
		embeds?: Embed[]
		/** Allowed mentions for the message */
		allowedMentions?: AllowedMentions
		/** Include to make your message a reply */
		messageReference?: MessageReference
		/** Components to include with the message */
		components?: Component[]
		/** IDs of up to 3 stickers in the server to send in the message */
		stickerIds?: Snowflake[]
		/** 	Contents of the file being sent. */
		files?: string[]
		/** 	Attachment objects with filename and description. */
		attachments?: Partial<Attachment>[]
		/** Message flags combined as a bitfield (only `SUPPRESS_EMBEDS` and `SUPPRESS_NOTIFICATIONS` can be set) */
		flags?: number
	} & (
		| {
				stickerIds?: Snowflake[]
				content: string
				files?: string[]
				embeds?: Embed[]
				components?: Component[]
		  }
		| {
				stickerIds?: Snowflake[]
				content?: string
				files: string[]
				embeds?: Embed[]
				components?: Component[]
		  }
		| {
				stickerIds?: Snowflake[]
				content?: string
				files?: string[]
				embeds: Embed[]
				components?: Component[]
		  }
		| {
				stickerIds: Snowflake[]
				content?: string
				files?: string[]
				embeds?: Embed[]
				components?: Component[]
		  }
		| {
				stickerIds?: Snowflake[]
				content?: string
				files?: string[]
				embeds?: Embed[]
				components: Component[]
		  }
	)
): Promise<Message> {
	return new Message(
		await request.post(`channels/${channelId}/messages`, message)
	)
}
type EditParams = {
	/** Message contents (up to 2000 characters) */
	content?: string | null
	/** Up to 10 `rich` embeds (up to 6000 characters) */
	embeds?: Embed[] | null
	/** Edit the flags of a message (only `SupressEmbeds` can currently be set/unset) */
	flags?: number | null
	/** Allowed mentions for the message */
	allowedMentions?: AllowedMentions | null
	/** Components to include with the message */
	components?: Component[] | null
	/** Contents of the file being sent/edited.  */
	files?: string[] | null
	/** Attached files to keep and possible descriptions for new files. */
	attachments?: Attachment[]
}
/** Updates a message */
async function edit(
	channelId: Snowflake,
	messageId: Snowflake,
	message: EditParams
): Promise<Message> {
	return new Message(
		await request.patch(`channels/${channelId}/messages/${messageId}`, message)
	)
}
/** Delete a single message */
async function _delete(
	channelId: Snowflake,
	messageId: Snowflake
): Promise<void> {
	await request.delete(`channels/${channelId}/messages/${messageId}`)
}
/** Delete an array of messages */
async function bulkDelete(
	channelId: Snowflake,
	messageIds: Snowflake[]
): Promise<void> {
	await request.post(`channels/${channelId}/messages/bulk-delete`, {
		messages: messageIds
	})
}
/** Retrieve a single message */
async function get(
	channelId: Snowflake,
	messageId: Snowflake
): Promise<Message> {
	return new Message(
		await request.get(`channels/${channelId}/messages/${messageId}`)
	)
}
/** Get an array of messages from a channel */
async function list(
	channelId: Snowflake,
	options?: {
		/** Get users after this user ID */
		after?: Snowflake
		/** Max number of users to return (1-100) */
		limit?: number
	}
): Promise<Message[]> {
	return (
		(await request.get(`channels/${channelId}/messages`, options)) as unknown[]
	).map((v) => new Message(v))
}
export enum ActivityType {
	Join = 1,
	Spectate = 2,
	Listen = 3,
	JoinRequest = 5
}
export enum MessageType {
	Default,
	RecipientAdd,
	RecipientRemove,
	Call,
	ChannelNameChange,
	ChannelIconChange,
	ChannelPinnedMessage,
	UserJoin,
	GuildBoost,
	GuildBoostTier1,
	GuildBoostTier2,
	GuildBoostTier3,
	ChannelFollowAdd,
	DiscoveryDisqualified,
	DiscoveryRequailified,
	DiscoveryGracePeriodInitialWarning,
	GuildDiscoveryGracePeriodFinalWarning,
	ThreadCreated,
	Reply,
	ChatInputCommand,
	ThreadStarterMessage,
	GuildInviteReminder,
	ContextMenuCommand,
	AutomodAction,
	RoleSubscriptionPurchase,
	InteractionPremiumUpsell,
	StageStart,
	StageEnd,
	StageSpeaker,
	StageTopic,
	ApplicationPremiumSubscription
}
export { create, edit, bulkDelete, get, list, _delete as delete }
export default { create, edit, delete: _delete, bulkDelete, get, list }

type _Message = {
	/** id of the message */
	id: Snowflake
	/** id of the channel the message was sent in */
	channelId: Snowflake
	/** the author of this message (not guaranteed to be a valid user) */
	author: User
	/** contents of the message */
	content: string
	/** when this message was sent */
	timestamp: string
	/** when this message was edited (or null if never) */
	editedTimestamp: string | null
	/** whether this was a TTS message */
	tts: boolean
	/** whether this message mentions everyone */
	mentionEveryone: boolean
	/** users specifically mentioned in the message */
	mentions: User[]
	/** roles specifically mentioned in this message */
	mentionRoles: string[]
	/** channels specifically mentioned in this message */
	mentionChannels?: ChannelMention[]
	/** any attached files */
	attachments: Attachment[]
	/** any embedded content */
	embeds: Embed[]
	/** reactions to the message */
	reactions: Reaction[]
	/** used for validating a message was sent */
	nonce?: number | string
	/** whether this message is pinned */
	pinned: boolean
	/** if the message is generated by a webhook, this is the webhook's id */
	webhookId?: Snowflake
	/** type of message */
	type: MessageType
	/** sent with Rich Presence-related chat embeds */
	activity?: MessageActivity
	/** sent with Rich Presence-related chat embeds */
	application?: Partial<Application>
	/** 	if the message is an Interaction or application-owned webhook, this is the id of the application */
	applicationId?: Snowflake
	/** data showing the source of a crosspost, channel follow add, pin, or reply message */
	messageReference?: MessageReference
	/** message flags combined as a bitfield */
	flags?: number
	/** the message associated with the message_reference */
	referencedMessage?: Message | null
	/** sent if the message is a response to an Interaction */
	interaction?: MessageInteraction
	/** the thread that was started from this message, includes thread member object */
	thread?: Channel
	/** sent if the message contains components like buttons, action rows, or other interactive components */
	components?: Component[]
	/** sent if the message contains stickers */
	stickerItems?: StickerItem[]
	/** **deprecated** - the stickers sent with the message */
	stickers?: Sticker[]
	/** A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with `total_message_sent` on parent thread */
	position?: number
	/** data of the role subscription purchase or renewal that prompted this ROLE_SUBSCRIPTION_PURCHASE message */
	roleSubscriptionData?: RoleSubscriptionData
}
type MessageInteraction = {
	/** ID of the interaction */
	id: Snowflake
	/** Type of interaction (`1`: Ping, `2`: Application Command, `3`: Message Component, `4`: Application Command Autocomplete, `5`: Modal Submit) */
	type: InteractionType
	/** Name of the application command, including subcommands and subcommand groups */
	name: string
	/** User who invoked the interaction */
	user: User
	/** Member who invoked the interaction in the guild */
	member?: Partial<GuildMember>
}
export type { _Message as Message }
